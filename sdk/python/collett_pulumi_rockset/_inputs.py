# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'RocksetDynamodbCollectionSourceArgs',
    'RocksetGcsCollectionSourceArgs',
    'RocksetGcsCollectionSourceCsvArgs',
    'RocksetGcsCollectionSourceXmlArgs',
    'RocksetKafkaCollectionSourceArgs',
    'RocksetKafkaCollectionSourceStatusArgs',
    'RocksetKafkaCollectionSourceStatusPartitionArgs',
    'RocksetKinesisCollectionSourceArgs',
    'RocksetMongodbCollectionSourceArgs',
    'RocksetQueryLambdaSqlArgs',
    'RocksetQueryLambdaSqlDefaultParameterArgs',
    'RocksetRolePrivilegeArgs',
    'RocksetS3CollectionSourceArgs',
    'RocksetS3CollectionSourceCsvArgs',
    'RocksetS3CollectionSourceXmlArgs',
]

@pulumi.input_type
class RocksetDynamodbCollectionSourceArgs:
    def __init__(__self__, *,
                 integration_name: pulumi.Input[str],
                 table_name: pulumi.Input[str],
                 aws_region: Optional[pulumi.Input[str]] = None,
                 rcu: Optional[pulumi.Input[int]] = None,
                 scan_end_time: Optional[pulumi.Input[str]] = None,
                 scan_records_processed: Optional[pulumi.Input[int]] = None,
                 scan_start_time: Optional[pulumi.Input[str]] = None,
                 scan_total_records: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 stream_last_processed_at: Optional[pulumi.Input[str]] = None,
                 use_scan_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] integration_name: The name of the Rockset DynamoDB integration.
        :param pulumi.Input[str] table_name: Name of DynamoDB table containing data.
        :param pulumi.Input[str] aws_region: AWS region name of DynamoDB table, by default us-west-2 is used.
        :param pulumi.Input[int] rcu: Max RCU usage for scan.
        :param pulumi.Input[str] scan_end_time: DynamoDB scan end time.
        :param pulumi.Input[int] scan_records_processed: Number of records inserted using scan.
        :param pulumi.Input[str] scan_start_time: DynamoDB scan start time.
        :param pulumi.Input[int] scan_total_records: Number of records in DynamoDB table at time of scan.
        :param pulumi.Input[str] state: State of current ingest for this table.
        :param pulumi.Input[str] stream_last_processed_at: ISO-8601 date when source was last processed.
        :param pulumi.Input[bool] use_scan_api: Whether the initial table scan should use the DynamoDB scan API. If false, export will be performed using an S3 bucket.
        """
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "table_name", table_name)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if rcu is not None:
            pulumi.set(__self__, "rcu", rcu)
        if scan_end_time is not None:
            pulumi.set(__self__, "scan_end_time", scan_end_time)
        if scan_records_processed is not None:
            pulumi.set(__self__, "scan_records_processed", scan_records_processed)
        if scan_start_time is not None:
            pulumi.set(__self__, "scan_start_time", scan_start_time)
        if scan_total_records is not None:
            pulumi.set(__self__, "scan_total_records", scan_total_records)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stream_last_processed_at is not None:
            pulumi.set(__self__, "stream_last_processed_at", stream_last_processed_at)
        if use_scan_api is not None:
            pulumi.set(__self__, "use_scan_api", use_scan_api)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset DynamoDB integration.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> pulumi.Input[str]:
        """
        Name of DynamoDB table containing data.
        """
        return pulumi.get(self, "table_name")

    @table_name.setter
    def table_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_name", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region name of DynamoDB table, by default us-west-2 is used.
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter
    def rcu(self) -> Optional[pulumi.Input[int]]:
        """
        Max RCU usage for scan.
        """
        return pulumi.get(self, "rcu")

    @rcu.setter
    def rcu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rcu", value)

    @property
    @pulumi.getter(name="scanEndTime")
    def scan_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        DynamoDB scan end time.
        """
        return pulumi.get(self, "scan_end_time")

    @scan_end_time.setter
    def scan_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_end_time", value)

    @property
    @pulumi.getter(name="scanRecordsProcessed")
    def scan_records_processed(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records inserted using scan.
        """
        return pulumi.get(self, "scan_records_processed")

    @scan_records_processed.setter
    def scan_records_processed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_records_processed", value)

    @property
    @pulumi.getter(name="scanStartTime")
    def scan_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        DynamoDB scan start time.
        """
        return pulumi.get(self, "scan_start_time")

    @scan_start_time.setter
    def scan_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_start_time", value)

    @property
    @pulumi.getter(name="scanTotalRecords")
    def scan_total_records(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records in DynamoDB table at time of scan.
        """
        return pulumi.get(self, "scan_total_records")

    @scan_total_records.setter
    def scan_total_records(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_total_records", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of current ingest for this table.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="streamLastProcessedAt")
    def stream_last_processed_at(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 date when source was last processed.
        """
        return pulumi.get(self, "stream_last_processed_at")

    @stream_last_processed_at.setter
    def stream_last_processed_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_last_processed_at", value)

    @property
    @pulumi.getter(name="useScanApi")
    def use_scan_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether the initial table scan should use the DynamoDB scan API. If false, export will be performed using an S3 bucket.
        """
        return pulumi.get(self, "use_scan_api")

    @use_scan_api.setter
    def use_scan_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_scan_api", value)


@pulumi.input_type
class RocksetGcsCollectionSourceArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 format: pulumi.Input[str],
                 integration_name: pulumi.Input[str],
                 csv: Optional[pulumi.Input['RocksetGcsCollectionSourceCsvArgs']] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 xml: Optional[pulumi.Input['RocksetGcsCollectionSourceXmlArgs']] = None):
        """
        :param pulumi.Input[str] bucket: GCS bucket containing the target data.
        :param pulumi.Input[str] format: Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        :param pulumi.Input[str] integration_name: The name of the Rockset GCS integration.
        :param pulumi.Input[str] prefix: Simple path prefix to GCS key.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if xml is not None:
            pulumi.set(__self__, "xml", xml)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        GCS bucket containing the target data.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset GCS integration.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['RocksetGcsCollectionSourceCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['RocksetGcsCollectionSourceCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Simple path prefix to GCS key.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def xml(self) -> Optional[pulumi.Input['RocksetGcsCollectionSourceXmlArgs']]:
        return pulumi.get(self, "xml")

    @xml.setter
    def xml(self, value: Optional[pulumi.Input['RocksetGcsCollectionSourceXmlArgs']]):
        pulumi.set(self, "xml", value)


@pulumi.input_type
class RocksetGcsCollectionSourceCsvArgs:
    def __init__(__self__, *,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 column_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 first_line_as_column_names: Optional[pulumi.Input[bool]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 separator: Optional[pulumi.Input[str]] = None):
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_types is not None:
            pulumi.set(__self__, "column_types", column_types)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_line_as_column_names is not None:
            pulumi.set(__self__, "first_line_as_column_names", first_line_as_column_names)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnTypes")
    def column_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "column_types")

    @column_types.setter
    def column_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_types", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="firstLineAsColumnNames")
    def first_line_as_column_names(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "first_line_as_column_names")

    @first_line_as_column_names.setter
    def first_line_as_column_names(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "first_line_as_column_names", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)


@pulumi.input_type
class RocksetGcsCollectionSourceXmlArgs:
    def __init__(__self__, *,
                 attribute_prefix: Optional[pulumi.Input[str]] = None,
                 doc_tag: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 root_tag: Optional[pulumi.Input[str]] = None,
                 value_tag: Optional[pulumi.Input[str]] = None):
        if attribute_prefix is not None:
            pulumi.set(__self__, "attribute_prefix", attribute_prefix)
        if doc_tag is not None:
            pulumi.set(__self__, "doc_tag", doc_tag)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if root_tag is not None:
            pulumi.set(__self__, "root_tag", root_tag)
        if value_tag is not None:
            pulumi.set(__self__, "value_tag", value_tag)

    @property
    @pulumi.getter(name="attributePrefix")
    def attribute_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_prefix")

    @attribute_prefix.setter
    def attribute_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_prefix", value)

    @property
    @pulumi.getter(name="docTag")
    def doc_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "doc_tag")

    @doc_tag.setter
    def doc_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "doc_tag", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="rootTag")
    def root_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "root_tag")

    @root_tag.setter
    def root_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_tag", value)

    @property
    @pulumi.getter(name="valueTag")
    def value_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value_tag")

    @value_tag.setter
    def value_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_tag", value)


@pulumi.input_type
class RocksetKafkaCollectionSourceArgs:
    def __init__(__self__, *,
                 integration_name: pulumi.Input[str],
                 topic_name: pulumi.Input[str],
                 consumer_group_id: Optional[pulumi.Input[str]] = None,
                 offset_reset_policy: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusArgs']]]] = None,
                 use_v3: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] integration_name: The name of the Rockset Kafka integration.
        :param pulumi.Input[str] topic_name: Name of Kafka topic to be tailed.
        :param pulumi.Input[str] consumer_group_id: The Kafka consumer group Id being used.
        :param pulumi.Input[str] offset_reset_policy: The offset reset policy. Possible values: LATEST, EARLIEST. Only valid with v3 collections.
        :param pulumi.Input[bool] use_v3: Whether to use v3 integration. Required if the kafka integration uses v3.
        """
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "topic_name", topic_name)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if offset_reset_policy is not None:
            pulumi.set(__self__, "offset_reset_policy", offset_reset_policy)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if use_v3 is not None:
            pulumi.set(__self__, "use_v3", use_v3)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset Kafka integration.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> pulumi.Input[str]:
        """
        Name of Kafka topic to be tailed.
        """
        return pulumi.get(self, "topic_name")

    @topic_name.setter
    def topic_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic_name", value)

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Kafka consumer group Id being used.
        """
        return pulumi.get(self, "consumer_group_id")

    @consumer_group_id.setter
    def consumer_group_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group_id", value)

    @property
    @pulumi.getter(name="offsetResetPolicy")
    def offset_reset_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The offset reset policy. Possible values: LATEST, EARLIEST. Only valid with v3 collections.
        """
        return pulumi.get(self, "offset_reset_policy")

    @offset_reset_policy.setter
    def offset_reset_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "offset_reset_policy", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusArgs']]]]:
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusArgs']]]]):
        pulumi.set(self, "statuses", value)

    @property
    @pulumi.getter(name="useV3")
    def use_v3(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use v3 integration. Required if the kafka integration uses v3.
        """
        return pulumi.get(self, "use_v3")

    @use_v3.setter
    def use_v3(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_v3", value)


@pulumi.input_type
class RocksetKafkaCollectionSourceStatusArgs:
    def __init__(__self__, *,
                 documents_processed: Optional[pulumi.Input[int]] = None,
                 last_consumed_time: Optional[pulumi.Input[str]] = None,
                 partitions: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusPartitionArgs']]]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        if documents_processed is not None:
            pulumi.set(__self__, "documents_processed", documents_processed)
        if last_consumed_time is not None:
            pulumi.set(__self__, "last_consumed_time", last_consumed_time)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="documentsProcessed")
    def documents_processed(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "documents_processed")

    @documents_processed.setter
    def documents_processed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "documents_processed", value)

    @property
    @pulumi.getter(name="lastConsumedTime")
    def last_consumed_time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "last_consumed_time")

    @last_consumed_time.setter
    def last_consumed_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_consumed_time", value)

    @property
    @pulumi.getter
    def partitions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusPartitionArgs']]]]:
        return pulumi.get(self, "partitions")

    @partitions.setter
    def partitions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetKafkaCollectionSourceStatusPartitionArgs']]]]):
        pulumi.set(self, "partitions", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class RocksetKafkaCollectionSourceStatusPartitionArgs:
    def __init__(__self__, *,
                 offset_lag: Optional[pulumi.Input[int]] = None,
                 partition_number: Optional[pulumi.Input[int]] = None,
                 partition_offset: Optional[pulumi.Input[int]] = None):
        if offset_lag is not None:
            pulumi.set(__self__, "offset_lag", offset_lag)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if partition_offset is not None:
            pulumi.set(__self__, "partition_offset", partition_offset)

    @property
    @pulumi.getter(name="offsetLag")
    def offset_lag(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "offset_lag")

    @offset_lag.setter
    def offset_lag(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "offset_lag", value)

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "partition_number")

    @partition_number.setter
    def partition_number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_number", value)

    @property
    @pulumi.getter(name="partitionOffset")
    def partition_offset(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "partition_offset")

    @partition_offset.setter
    def partition_offset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "partition_offset", value)


@pulumi.input_type
class RocksetKinesisCollectionSourceArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 integration_name: pulumi.Input[str],
                 stream_name: pulumi.Input[str],
                 aws_region: Optional[pulumi.Input[str]] = None,
                 dms_primary_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] format: Format of the data. One of: json, mysql, postgres. dms*primary*keys list can only be set for mysql or postgres.
        :param pulumi.Input[str] integration_name: The name of the Rockset Kinesis integration.
        :param pulumi.Input[str] stream_name: Name of Kinesis stream.
        :param pulumi.Input[str] aws_region: AWS region name for the Kinesis stream, by default us-west-2 is used
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dms_primary_keys: Set of fields that correspond to a DMS primary key. Can only be set if format is mysql or postgres.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if dms_primary_keys is not None:
            pulumi.set(__self__, "dms_primary_keys", dms_primary_keys)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Format of the data. One of: json, mysql, postgres. dms*primary*keys list can only be set for mysql or postgres.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset Kinesis integration.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[str]:
        """
        Name of Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "stream_name", value)

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[pulumi.Input[str]]:
        """
        AWS region name for the Kinesis stream, by default us-west-2 is used
        """
        return pulumi.get(self, "aws_region")

    @aws_region.setter
    def aws_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aws_region", value)

    @property
    @pulumi.getter(name="dmsPrimaryKeys")
    def dms_primary_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of fields that correspond to a DMS primary key. Can only be set if format is mysql or postgres.
        """
        return pulumi.get(self, "dms_primary_keys")

    @dms_primary_keys.setter
    def dms_primary_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dms_primary_keys", value)


@pulumi.input_type
class RocksetMongodbCollectionSourceArgs:
    def __init__(__self__, *,
                 collection_name: pulumi.Input[str],
                 database_name: pulumi.Input[str],
                 integration_name: pulumi.Input[str],
                 scan_end_time: Optional[pulumi.Input[str]] = None,
                 scan_records_processed: Optional[pulumi.Input[int]] = None,
                 scan_start_time: Optional[pulumi.Input[str]] = None,
                 scan_total_records: Optional[pulumi.Input[int]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 stream_last_delete_processed_at: Optional[pulumi.Input[str]] = None,
                 stream_last_insert_processed_at: Optional[pulumi.Input[str]] = None,
                 stream_last_update_processed_at: Optional[pulumi.Input[str]] = None,
                 stream_records_deleted: Optional[pulumi.Input[int]] = None,
                 stream_records_inserted: Optional[pulumi.Input[int]] = None,
                 stream_records_updated: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] collection_name: MongoDB collection name of the target collection.
        :param pulumi.Input[str] database_name: MongoDB database name containing the target collection.
        :param pulumi.Input[str] integration_name: The name of the Rockset MongoDB integration.
        :param pulumi.Input[str] scan_end_time: MongoDB scan end time.
        :param pulumi.Input[int] scan_records_processed: Number of records inserted using scan.
        :param pulumi.Input[str] scan_start_time: MongoDB scan start time.
        :param pulumi.Input[int] scan_total_records: Number of records in MongoDB table at time of scan.
        :param pulumi.Input[str] state: State of current ingest for this table.
        :param pulumi.Input[str] stream_last_delete_processed_at: ISO-8601 date when delete from source was last processed.
        :param pulumi.Input[str] stream_last_insert_processed_at: ISO-8601 date when new insert from source was last processed.
        :param pulumi.Input[str] stream_last_update_processed_at: ISO-8601 date when update from source was last processed.
        :param pulumi.Input[int] stream_records_deleted: Number of new records deleted using stream.
        :param pulumi.Input[int] stream_records_inserted: Number of new records inserted using stream.
        :param pulumi.Input[int] stream_records_updated: Number of new records updated using stream.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "integration_name", integration_name)
        if scan_end_time is not None:
            pulumi.set(__self__, "scan_end_time", scan_end_time)
        if scan_records_processed is not None:
            pulumi.set(__self__, "scan_records_processed", scan_records_processed)
        if scan_start_time is not None:
            pulumi.set(__self__, "scan_start_time", scan_start_time)
        if scan_total_records is not None:
            pulumi.set(__self__, "scan_total_records", scan_total_records)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stream_last_delete_processed_at is not None:
            pulumi.set(__self__, "stream_last_delete_processed_at", stream_last_delete_processed_at)
        if stream_last_insert_processed_at is not None:
            pulumi.set(__self__, "stream_last_insert_processed_at", stream_last_insert_processed_at)
        if stream_last_update_processed_at is not None:
            pulumi.set(__self__, "stream_last_update_processed_at", stream_last_update_processed_at)
        if stream_records_deleted is not None:
            pulumi.set(__self__, "stream_records_deleted", stream_records_deleted)
        if stream_records_inserted is not None:
            pulumi.set(__self__, "stream_records_inserted", stream_records_inserted)
        if stream_records_updated is not None:
            pulumi.set(__self__, "stream_records_updated", stream_records_updated)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> pulumi.Input[str]:
        """
        MongoDB collection name of the target collection.
        """
        return pulumi.get(self, "collection_name")

    @collection_name.setter
    def collection_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "collection_name", value)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        MongoDB database name containing the target collection.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset MongoDB integration.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter(name="scanEndTime")
    def scan_end_time(self) -> Optional[pulumi.Input[str]]:
        """
        MongoDB scan end time.
        """
        return pulumi.get(self, "scan_end_time")

    @scan_end_time.setter
    def scan_end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_end_time", value)

    @property
    @pulumi.getter(name="scanRecordsProcessed")
    def scan_records_processed(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records inserted using scan.
        """
        return pulumi.get(self, "scan_records_processed")

    @scan_records_processed.setter
    def scan_records_processed(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_records_processed", value)

    @property
    @pulumi.getter(name="scanStartTime")
    def scan_start_time(self) -> Optional[pulumi.Input[str]]:
        """
        MongoDB scan start time.
        """
        return pulumi.get(self, "scan_start_time")

    @scan_start_time.setter
    def scan_start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scan_start_time", value)

    @property
    @pulumi.getter(name="scanTotalRecords")
    def scan_total_records(self) -> Optional[pulumi.Input[int]]:
        """
        Number of records in MongoDB table at time of scan.
        """
        return pulumi.get(self, "scan_total_records")

    @scan_total_records.setter
    def scan_total_records(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_total_records", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        State of current ingest for this table.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="streamLastDeleteProcessedAt")
    def stream_last_delete_processed_at(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 date when delete from source was last processed.
        """
        return pulumi.get(self, "stream_last_delete_processed_at")

    @stream_last_delete_processed_at.setter
    def stream_last_delete_processed_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_last_delete_processed_at", value)

    @property
    @pulumi.getter(name="streamLastInsertProcessedAt")
    def stream_last_insert_processed_at(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 date when new insert from source was last processed.
        """
        return pulumi.get(self, "stream_last_insert_processed_at")

    @stream_last_insert_processed_at.setter
    def stream_last_insert_processed_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_last_insert_processed_at", value)

    @property
    @pulumi.getter(name="streamLastUpdateProcessedAt")
    def stream_last_update_processed_at(self) -> Optional[pulumi.Input[str]]:
        """
        ISO-8601 date when update from source was last processed.
        """
        return pulumi.get(self, "stream_last_update_processed_at")

    @stream_last_update_processed_at.setter
    def stream_last_update_processed_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "stream_last_update_processed_at", value)

    @property
    @pulumi.getter(name="streamRecordsDeleted")
    def stream_records_deleted(self) -> Optional[pulumi.Input[int]]:
        """
        Number of new records deleted using stream.
        """
        return pulumi.get(self, "stream_records_deleted")

    @stream_records_deleted.setter
    def stream_records_deleted(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_records_deleted", value)

    @property
    @pulumi.getter(name="streamRecordsInserted")
    def stream_records_inserted(self) -> Optional[pulumi.Input[int]]:
        """
        Number of new records inserted using stream.
        """
        return pulumi.get(self, "stream_records_inserted")

    @stream_records_inserted.setter
    def stream_records_inserted(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_records_inserted", value)

    @property
    @pulumi.getter(name="streamRecordsUpdated")
    def stream_records_updated(self) -> Optional[pulumi.Input[int]]:
        """
        Number of new records updated using stream.
        """
        return pulumi.get(self, "stream_records_updated")

    @stream_records_updated.setter
    def stream_records_updated(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "stream_records_updated", value)


@pulumi.input_type
class RocksetQueryLambdaSqlArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 default_parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetQueryLambdaSqlDefaultParameterArgs']]]] = None):
        pulumi.set(__self__, "query", query)
        if default_parameters is not None:
            pulumi.set(__self__, "default_parameters", default_parameters)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="defaultParameters")
    def default_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RocksetQueryLambdaSqlDefaultParameterArgs']]]]:
        return pulumi.get(self, "default_parameters")

    @default_parameters.setter
    def default_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RocksetQueryLambdaSqlDefaultParameterArgs']]]]):
        pulumi.set(self, "default_parameters", value)


@pulumi.input_type
class RocksetQueryLambdaSqlDefaultParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Unique identifier for the query lambda. Can contain alphanumeric or dash characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Unique identifier for the query lambda. Can contain alphanumeric or dash characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RocksetRolePrivilegeArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 cluster: Optional[pulumi.Input[str]] = None,
                 resource_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] action: The action allowed by this privilege.
        :param pulumi.Input[str] cluster: Rockset cluster ID for which this action is allowed. Only valid for Workspace actions. Use '*ALL*' for actions which apply to all clusters.
        :param pulumi.Input[str] resource_name: The resource on which this action is allowed. Defaults to 'All' if not specified.
        """
        pulumi.set(__self__, "action", action)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action allowed by this privilege.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Rockset cluster ID for which this action is allowed. Only valid for Workspace actions. Use '*ALL*' for actions which apply to all clusters.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[pulumi.Input[str]]:
        """
        The resource on which this action is allowed. Defaults to 'All' if not specified.
        """
        return pulumi.get(self, "resource_name")

    @resource_name.setter
    def resource_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_name", value)


@pulumi.input_type
class RocksetS3CollectionSourceArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 format: pulumi.Input[str],
                 integration_name: pulumi.Input[str],
                 csv: Optional[pulumi.Input['RocksetS3CollectionSourceCsvArgs']] = None,
                 pattern: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 xml: Optional[pulumi.Input['RocksetS3CollectionSourceXmlArgs']] = None):
        """
        :param pulumi.Input[str] bucket: S3 bucket containing the target data.
        :param pulumi.Input[str] format: Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        :param pulumi.Input[str] integration_name: The name of the Rockset S3 integration. If no S3 integration is provided only data in public S3 buckets are accessible.
        :param pulumi.Input[str] pattern: Regex path pattern to S3 keys.
        :param pulumi.Input[str] prefix: Simple path prefix to S3 keys.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if prefix is not None:
            warnings.warn("""use pattern instead""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: use pattern instead""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if xml is not None:
            pulumi.set(__self__, "xml", xml)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        S3 bucket containing the target data.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        """
        Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> pulumi.Input[str]:
        """
        The name of the Rockset S3 integration. If no S3 integration is provided only data in public S3 buckets are accessible.
        """
        return pulumi.get(self, "integration_name")

    @integration_name.setter
    def integration_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "integration_name", value)

    @property
    @pulumi.getter
    def csv(self) -> Optional[pulumi.Input['RocksetS3CollectionSourceCsvArgs']]:
        return pulumi.get(self, "csv")

    @csv.setter
    def csv(self, value: Optional[pulumi.Input['RocksetS3CollectionSourceCsvArgs']]):
        pulumi.set(self, "csv", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Regex path pattern to S3 keys.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Simple path prefix to S3 keys.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def xml(self) -> Optional[pulumi.Input['RocksetS3CollectionSourceXmlArgs']]:
        return pulumi.get(self, "xml")

    @xml.setter
    def xml(self, value: Optional[pulumi.Input['RocksetS3CollectionSourceXmlArgs']]):
        pulumi.set(self, "xml", value)


@pulumi.input_type
class RocksetS3CollectionSourceCsvArgs:
    def __init__(__self__, *,
                 column_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 column_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 escape_char: Optional[pulumi.Input[str]] = None,
                 first_line_as_column_names: Optional[pulumi.Input[bool]] = None,
                 quote_char: Optional[pulumi.Input[str]] = None,
                 separator: Optional[pulumi.Input[str]] = None):
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_types is not None:
            pulumi.set(__self__, "column_types", column_types)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_line_as_column_names is not None:
            pulumi.set(__self__, "first_line_as_column_names", first_line_as_column_names)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "column_names")

    @column_names.setter
    def column_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_names", value)

    @property
    @pulumi.getter(name="columnTypes")
    def column_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "column_types")

    @column_types.setter
    def column_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "column_types", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "escape_char")

    @escape_char.setter
    def escape_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escape_char", value)

    @property
    @pulumi.getter(name="firstLineAsColumnNames")
    def first_line_as_column_names(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "first_line_as_column_names")

    @first_line_as_column_names.setter
    def first_line_as_column_names(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "first_line_as_column_names", value)

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "quote_char")

    @quote_char.setter
    def quote_char(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote_char", value)

    @property
    @pulumi.getter
    def separator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "separator")

    @separator.setter
    def separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "separator", value)


@pulumi.input_type
class RocksetS3CollectionSourceXmlArgs:
    def __init__(__self__, *,
                 attribute_prefix: Optional[pulumi.Input[str]] = None,
                 doc_tag: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 root_tag: Optional[pulumi.Input[str]] = None,
                 value_tag: Optional[pulumi.Input[str]] = None):
        if attribute_prefix is not None:
            pulumi.set(__self__, "attribute_prefix", attribute_prefix)
        if doc_tag is not None:
            pulumi.set(__self__, "doc_tag", doc_tag)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if root_tag is not None:
            pulumi.set(__self__, "root_tag", root_tag)
        if value_tag is not None:
            pulumi.set(__self__, "value_tag", value_tag)

    @property
    @pulumi.getter(name="attributePrefix")
    def attribute_prefix(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "attribute_prefix")

    @attribute_prefix.setter
    def attribute_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "attribute_prefix", value)

    @property
    @pulumi.getter(name="docTag")
    def doc_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "doc_tag")

    @doc_tag.setter
    def doc_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "doc_tag", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="rootTag")
    def root_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "root_tag")

    @root_tag.setter
    def root_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_tag", value)

    @property
    @pulumi.getter(name="valueTag")
    def value_tag(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value_tag")

    @value_tag.setter
    def value_tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_tag", value)


