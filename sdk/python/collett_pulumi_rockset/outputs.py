# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'RocksetDynamodbCollectionSource',
    'RocksetGcsCollectionSource',
    'RocksetGcsCollectionSourceCsv',
    'RocksetGcsCollectionSourceXml',
    'RocksetKafkaCollectionSource',
    'RocksetKafkaCollectionSourceStatus',
    'RocksetKafkaCollectionSourceStatusPartition',
    'RocksetKinesisCollectionSource',
    'RocksetMongodbCollectionSource',
    'RocksetQueryLambdaSql',
    'RocksetQueryLambdaSqlDefaultParameter',
    'RocksetRolePrivilege',
    'RocksetS3CollectionSource',
    'RocksetS3CollectionSourceCsv',
    'RocksetS3CollectionSourceXml',
    'GetAccountClusterResult',
]

@pulumi.output_type
class RocksetDynamodbCollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationName":
            suggest = "integration_name"
        elif key == "tableName":
            suggest = "table_name"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "scanEndTime":
            suggest = "scan_end_time"
        elif key == "scanRecordsProcessed":
            suggest = "scan_records_processed"
        elif key == "scanStartTime":
            suggest = "scan_start_time"
        elif key == "scanTotalRecords":
            suggest = "scan_total_records"
        elif key == "streamLastProcessedAt":
            suggest = "stream_last_processed_at"
        elif key == "useScanApi":
            suggest = "use_scan_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetDynamodbCollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetDynamodbCollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetDynamodbCollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_name: str,
                 table_name: str,
                 aws_region: Optional[str] = None,
                 rcu: Optional[int] = None,
                 scan_end_time: Optional[str] = None,
                 scan_records_processed: Optional[int] = None,
                 scan_start_time: Optional[str] = None,
                 scan_total_records: Optional[int] = None,
                 state: Optional[str] = None,
                 stream_last_processed_at: Optional[str] = None,
                 use_scan_api: Optional[bool] = None):
        """
        :param str integration_name: The name of the Rockset DynamoDB integration.
        :param str table_name: Name of DynamoDB table containing data.
        :param str aws_region: AWS region name of DynamoDB table, by default us-west-2 is used.
        :param int rcu: Max RCU usage for scan.
        :param str scan_end_time: DynamoDB scan end time.
        :param int scan_records_processed: Number of records inserted using scan.
        :param str scan_start_time: DynamoDB scan start time.
        :param int scan_total_records: Number of records in DynamoDB table at time of scan.
        :param str state: State of current ingest for this table.
        :param str stream_last_processed_at: ISO-8601 date when source was last processed.
        :param bool use_scan_api: Whether the initial table scan should use the DynamoDB scan API. If false, export will be performed using an S3 bucket.
        """
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "table_name", table_name)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if rcu is not None:
            pulumi.set(__self__, "rcu", rcu)
        if scan_end_time is not None:
            pulumi.set(__self__, "scan_end_time", scan_end_time)
        if scan_records_processed is not None:
            pulumi.set(__self__, "scan_records_processed", scan_records_processed)
        if scan_start_time is not None:
            pulumi.set(__self__, "scan_start_time", scan_start_time)
        if scan_total_records is not None:
            pulumi.set(__self__, "scan_total_records", scan_total_records)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stream_last_processed_at is not None:
            pulumi.set(__self__, "stream_last_processed_at", stream_last_processed_at)
        if use_scan_api is not None:
            pulumi.set(__self__, "use_scan_api", use_scan_api)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset DynamoDB integration.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        Name of DynamoDB table containing data.
        """
        return pulumi.get(self, "table_name")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS region name of DynamoDB table, by default us-west-2 is used.
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter
    def rcu(self) -> Optional[int]:
        """
        Max RCU usage for scan.
        """
        return pulumi.get(self, "rcu")

    @property
    @pulumi.getter(name="scanEndTime")
    def scan_end_time(self) -> Optional[str]:
        """
        DynamoDB scan end time.
        """
        return pulumi.get(self, "scan_end_time")

    @property
    @pulumi.getter(name="scanRecordsProcessed")
    def scan_records_processed(self) -> Optional[int]:
        """
        Number of records inserted using scan.
        """
        return pulumi.get(self, "scan_records_processed")

    @property
    @pulumi.getter(name="scanStartTime")
    def scan_start_time(self) -> Optional[str]:
        """
        DynamoDB scan start time.
        """
        return pulumi.get(self, "scan_start_time")

    @property
    @pulumi.getter(name="scanTotalRecords")
    def scan_total_records(self) -> Optional[int]:
        """
        Number of records in DynamoDB table at time of scan.
        """
        return pulumi.get(self, "scan_total_records")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of current ingest for this table.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="streamLastProcessedAt")
    def stream_last_processed_at(self) -> Optional[str]:
        """
        ISO-8601 date when source was last processed.
        """
        return pulumi.get(self, "stream_last_processed_at")

    @property
    @pulumi.getter(name="useScanApi")
    def use_scan_api(self) -> Optional[bool]:
        """
        Whether the initial table scan should use the DynamoDB scan API. If false, export will be performed using an S3 bucket.
        """
        return pulumi.get(self, "use_scan_api")


@pulumi.output_type
class RocksetGcsCollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationName":
            suggest = "integration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetGcsCollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetGcsCollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetGcsCollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 format: str,
                 integration_name: str,
                 csv: Optional['outputs.RocksetGcsCollectionSourceCsv'] = None,
                 prefix: Optional[str] = None,
                 xml: Optional['outputs.RocksetGcsCollectionSourceXml'] = None):
        """
        :param str bucket: GCS bucket containing the target data.
        :param str format: Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        :param str integration_name: The name of the Rockset GCS integration.
        :param str prefix: Simple path prefix to GCS key.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if xml is not None:
            pulumi.set(__self__, "xml", xml)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        GCS bucket containing the target data.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset GCS integration.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter
    def csv(self) -> Optional['outputs.RocksetGcsCollectionSourceCsv']:
        return pulumi.get(self, "csv")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Simple path prefix to GCS key.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def xml(self) -> Optional['outputs.RocksetGcsCollectionSourceXml']:
        return pulumi.get(self, "xml")


@pulumi.output_type
class RocksetGcsCollectionSourceCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"
        elif key == "columnTypes":
            suggest = "column_types"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "firstLineAsColumnNames":
            suggest = "first_line_as_column_names"
        elif key == "quoteChar":
            suggest = "quote_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetGcsCollectionSourceCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetGcsCollectionSourceCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetGcsCollectionSourceCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Optional[Sequence[str]] = None,
                 column_types: Optional[Sequence[str]] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 first_line_as_column_names: Optional[bool] = None,
                 quote_char: Optional[str] = None,
                 separator: Optional[str] = None):
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_types is not None:
            pulumi.set(__self__, "column_types", column_types)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_line_as_column_names is not None:
            pulumi.set(__self__, "first_line_as_column_names", first_line_as_column_names)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter(name="columnTypes")
    def column_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_types")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="firstLineAsColumnNames")
    def first_line_as_column_names(self) -> Optional[bool]:
        return pulumi.get(self, "first_line_as_column_names")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter
    def separator(self) -> Optional[str]:
        return pulumi.get(self, "separator")


@pulumi.output_type
class RocksetGcsCollectionSourceXml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributePrefix":
            suggest = "attribute_prefix"
        elif key == "docTag":
            suggest = "doc_tag"
        elif key == "rootTag":
            suggest = "root_tag"
        elif key == "valueTag":
            suggest = "value_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetGcsCollectionSourceXml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetGcsCollectionSourceXml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetGcsCollectionSourceXml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_prefix: Optional[str] = None,
                 doc_tag: Optional[str] = None,
                 encoding: Optional[str] = None,
                 root_tag: Optional[str] = None,
                 value_tag: Optional[str] = None):
        if attribute_prefix is not None:
            pulumi.set(__self__, "attribute_prefix", attribute_prefix)
        if doc_tag is not None:
            pulumi.set(__self__, "doc_tag", doc_tag)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if root_tag is not None:
            pulumi.set(__self__, "root_tag", root_tag)
        if value_tag is not None:
            pulumi.set(__self__, "value_tag", value_tag)

    @property
    @pulumi.getter(name="attributePrefix")
    def attribute_prefix(self) -> Optional[str]:
        return pulumi.get(self, "attribute_prefix")

    @property
    @pulumi.getter(name="docTag")
    def doc_tag(self) -> Optional[str]:
        return pulumi.get(self, "doc_tag")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="rootTag")
    def root_tag(self) -> Optional[str]:
        return pulumi.get(self, "root_tag")

    @property
    @pulumi.getter(name="valueTag")
    def value_tag(self) -> Optional[str]:
        return pulumi.get(self, "value_tag")


@pulumi.output_type
class RocksetKafkaCollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationName":
            suggest = "integration_name"
        elif key == "topicName":
            suggest = "topic_name"
        elif key == "consumerGroupId":
            suggest = "consumer_group_id"
        elif key == "offsetResetPolicy":
            suggest = "offset_reset_policy"
        elif key == "useV3":
            suggest = "use_v3"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetKafkaCollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetKafkaCollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetKafkaCollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_name: str,
                 topic_name: str,
                 consumer_group_id: Optional[str] = None,
                 offset_reset_policy: Optional[str] = None,
                 statuses: Optional[Sequence['outputs.RocksetKafkaCollectionSourceStatus']] = None,
                 use_v3: Optional[bool] = None):
        """
        :param str integration_name: The name of the Rockset Kafka integration.
        :param str topic_name: Name of Kafka topic to be tailed.
        :param str consumer_group_id: The Kafka consumer group Id being used.
        :param str offset_reset_policy: The offset reset policy. Possible values: LATEST, EARLIEST. Only valid with v3 collections.
        :param bool use_v3: Whether to use v3 integration. Required if the kafka integration uses v3.
        """
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "topic_name", topic_name)
        if consumer_group_id is not None:
            pulumi.set(__self__, "consumer_group_id", consumer_group_id)
        if offset_reset_policy is not None:
            pulumi.set(__self__, "offset_reset_policy", offset_reset_policy)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if use_v3 is not None:
            pulumi.set(__self__, "use_v3", use_v3)

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset Kafka integration.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter(name="topicName")
    def topic_name(self) -> str:
        """
        Name of Kafka topic to be tailed.
        """
        return pulumi.get(self, "topic_name")

    @property
    @pulumi.getter(name="consumerGroupId")
    def consumer_group_id(self) -> Optional[str]:
        """
        The Kafka consumer group Id being used.
        """
        return pulumi.get(self, "consumer_group_id")

    @property
    @pulumi.getter(name="offsetResetPolicy")
    def offset_reset_policy(self) -> Optional[str]:
        """
        The offset reset policy. Possible values: LATEST, EARLIEST. Only valid with v3 collections.
        """
        return pulumi.get(self, "offset_reset_policy")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.RocksetKafkaCollectionSourceStatus']]:
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter(name="useV3")
    def use_v3(self) -> Optional[bool]:
        """
        Whether to use v3 integration. Required if the kafka integration uses v3.
        """
        return pulumi.get(self, "use_v3")


@pulumi.output_type
class RocksetKafkaCollectionSourceStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "documentsProcessed":
            suggest = "documents_processed"
        elif key == "lastConsumedTime":
            suggest = "last_consumed_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetKafkaCollectionSourceStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetKafkaCollectionSourceStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetKafkaCollectionSourceStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 documents_processed: Optional[int] = None,
                 last_consumed_time: Optional[str] = None,
                 partitions: Optional[Sequence['outputs.RocksetKafkaCollectionSourceStatusPartition']] = None,
                 state: Optional[str] = None):
        if documents_processed is not None:
            pulumi.set(__self__, "documents_processed", documents_processed)
        if last_consumed_time is not None:
            pulumi.set(__self__, "last_consumed_time", last_consumed_time)
        if partitions is not None:
            pulumi.set(__self__, "partitions", partitions)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="documentsProcessed")
    def documents_processed(self) -> Optional[int]:
        return pulumi.get(self, "documents_processed")

    @property
    @pulumi.getter(name="lastConsumedTime")
    def last_consumed_time(self) -> Optional[str]:
        return pulumi.get(self, "last_consumed_time")

    @property
    @pulumi.getter
    def partitions(self) -> Optional[Sequence['outputs.RocksetKafkaCollectionSourceStatusPartition']]:
        return pulumi.get(self, "partitions")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        return pulumi.get(self, "state")


@pulumi.output_type
class RocksetKafkaCollectionSourceStatusPartition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offsetLag":
            suggest = "offset_lag"
        elif key == "partitionNumber":
            suggest = "partition_number"
        elif key == "partitionOffset":
            suggest = "partition_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetKafkaCollectionSourceStatusPartition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetKafkaCollectionSourceStatusPartition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetKafkaCollectionSourceStatusPartition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 offset_lag: Optional[int] = None,
                 partition_number: Optional[int] = None,
                 partition_offset: Optional[int] = None):
        if offset_lag is not None:
            pulumi.set(__self__, "offset_lag", offset_lag)
        if partition_number is not None:
            pulumi.set(__self__, "partition_number", partition_number)
        if partition_offset is not None:
            pulumi.set(__self__, "partition_offset", partition_offset)

    @property
    @pulumi.getter(name="offsetLag")
    def offset_lag(self) -> Optional[int]:
        return pulumi.get(self, "offset_lag")

    @property
    @pulumi.getter(name="partitionNumber")
    def partition_number(self) -> Optional[int]:
        return pulumi.get(self, "partition_number")

    @property
    @pulumi.getter(name="partitionOffset")
    def partition_offset(self) -> Optional[int]:
        return pulumi.get(self, "partition_offset")


@pulumi.output_type
class RocksetKinesisCollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationName":
            suggest = "integration_name"
        elif key == "streamName":
            suggest = "stream_name"
        elif key == "awsRegion":
            suggest = "aws_region"
        elif key == "dmsPrimaryKeys":
            suggest = "dms_primary_keys"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetKinesisCollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetKinesisCollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetKinesisCollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 format: str,
                 integration_name: str,
                 stream_name: str,
                 aws_region: Optional[str] = None,
                 dms_primary_keys: Optional[Sequence[str]] = None):
        """
        :param str format: Format of the data. One of: json, mysql, postgres. dms*primary*keys list can only be set for mysql or postgres.
        :param str integration_name: The name of the Rockset Kinesis integration.
        :param str stream_name: Name of Kinesis stream.
        :param str aws_region: AWS region name for the Kinesis stream, by default us-west-2 is used
        :param Sequence[str] dms_primary_keys: Set of fields that correspond to a DMS primary key. Can only be set if format is mysql or postgres.
        """
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        pulumi.set(__self__, "stream_name", stream_name)
        if aws_region is not None:
            pulumi.set(__self__, "aws_region", aws_region)
        if dms_primary_keys is not None:
            pulumi.set(__self__, "dms_primary_keys", dms_primary_keys)

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Format of the data. One of: json, mysql, postgres. dms*primary*keys list can only be set for mysql or postgres.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset Kinesis integration.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> str:
        """
        Name of Kinesis stream.
        """
        return pulumi.get(self, "stream_name")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> Optional[str]:
        """
        AWS region name for the Kinesis stream, by default us-west-2 is used
        """
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter(name="dmsPrimaryKeys")
    def dms_primary_keys(self) -> Optional[Sequence[str]]:
        """
        Set of fields that correspond to a DMS primary key. Can only be set if format is mysql or postgres.
        """
        return pulumi.get(self, "dms_primary_keys")


@pulumi.output_type
class RocksetMongodbCollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionName":
            suggest = "collection_name"
        elif key == "databaseName":
            suggest = "database_name"
        elif key == "integrationName":
            suggest = "integration_name"
        elif key == "scanEndTime":
            suggest = "scan_end_time"
        elif key == "scanRecordsProcessed":
            suggest = "scan_records_processed"
        elif key == "scanStartTime":
            suggest = "scan_start_time"
        elif key == "scanTotalRecords":
            suggest = "scan_total_records"
        elif key == "streamLastDeleteProcessedAt":
            suggest = "stream_last_delete_processed_at"
        elif key == "streamLastInsertProcessedAt":
            suggest = "stream_last_insert_processed_at"
        elif key == "streamLastUpdateProcessedAt":
            suggest = "stream_last_update_processed_at"
        elif key == "streamRecordsDeleted":
            suggest = "stream_records_deleted"
        elif key == "streamRecordsInserted":
            suggest = "stream_records_inserted"
        elif key == "streamRecordsUpdated":
            suggest = "stream_records_updated"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetMongodbCollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetMongodbCollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetMongodbCollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection_name: str,
                 database_name: str,
                 integration_name: str,
                 scan_end_time: Optional[str] = None,
                 scan_records_processed: Optional[int] = None,
                 scan_start_time: Optional[str] = None,
                 scan_total_records: Optional[int] = None,
                 state: Optional[str] = None,
                 stream_last_delete_processed_at: Optional[str] = None,
                 stream_last_insert_processed_at: Optional[str] = None,
                 stream_last_update_processed_at: Optional[str] = None,
                 stream_records_deleted: Optional[int] = None,
                 stream_records_inserted: Optional[int] = None,
                 stream_records_updated: Optional[int] = None):
        """
        :param str collection_name: MongoDB collection name of the target collection.
        :param str database_name: MongoDB database name containing the target collection.
        :param str integration_name: The name of the Rockset MongoDB integration.
        :param str scan_end_time: MongoDB scan end time.
        :param int scan_records_processed: Number of records inserted using scan.
        :param str scan_start_time: MongoDB scan start time.
        :param int scan_total_records: Number of records in MongoDB table at time of scan.
        :param str state: State of current ingest for this table.
        :param str stream_last_delete_processed_at: ISO-8601 date when delete from source was last processed.
        :param str stream_last_insert_processed_at: ISO-8601 date when new insert from source was last processed.
        :param str stream_last_update_processed_at: ISO-8601 date when update from source was last processed.
        :param int stream_records_deleted: Number of new records deleted using stream.
        :param int stream_records_inserted: Number of new records inserted using stream.
        :param int stream_records_updated: Number of new records updated using stream.
        """
        pulumi.set(__self__, "collection_name", collection_name)
        pulumi.set(__self__, "database_name", database_name)
        pulumi.set(__self__, "integration_name", integration_name)
        if scan_end_time is not None:
            pulumi.set(__self__, "scan_end_time", scan_end_time)
        if scan_records_processed is not None:
            pulumi.set(__self__, "scan_records_processed", scan_records_processed)
        if scan_start_time is not None:
            pulumi.set(__self__, "scan_start_time", scan_start_time)
        if scan_total_records is not None:
            pulumi.set(__self__, "scan_total_records", scan_total_records)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if stream_last_delete_processed_at is not None:
            pulumi.set(__self__, "stream_last_delete_processed_at", stream_last_delete_processed_at)
        if stream_last_insert_processed_at is not None:
            pulumi.set(__self__, "stream_last_insert_processed_at", stream_last_insert_processed_at)
        if stream_last_update_processed_at is not None:
            pulumi.set(__self__, "stream_last_update_processed_at", stream_last_update_processed_at)
        if stream_records_deleted is not None:
            pulumi.set(__self__, "stream_records_deleted", stream_records_deleted)
        if stream_records_inserted is not None:
            pulumi.set(__self__, "stream_records_inserted", stream_records_inserted)
        if stream_records_updated is not None:
            pulumi.set(__self__, "stream_records_updated", stream_records_updated)

    @property
    @pulumi.getter(name="collectionName")
    def collection_name(self) -> str:
        """
        MongoDB collection name of the target collection.
        """
        return pulumi.get(self, "collection_name")

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> str:
        """
        MongoDB database name containing the target collection.
        """
        return pulumi.get(self, "database_name")

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset MongoDB integration.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter(name="scanEndTime")
    def scan_end_time(self) -> Optional[str]:
        """
        MongoDB scan end time.
        """
        return pulumi.get(self, "scan_end_time")

    @property
    @pulumi.getter(name="scanRecordsProcessed")
    def scan_records_processed(self) -> Optional[int]:
        """
        Number of records inserted using scan.
        """
        return pulumi.get(self, "scan_records_processed")

    @property
    @pulumi.getter(name="scanStartTime")
    def scan_start_time(self) -> Optional[str]:
        """
        MongoDB scan start time.
        """
        return pulumi.get(self, "scan_start_time")

    @property
    @pulumi.getter(name="scanTotalRecords")
    def scan_total_records(self) -> Optional[int]:
        """
        Number of records in MongoDB table at time of scan.
        """
        return pulumi.get(self, "scan_total_records")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        State of current ingest for this table.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter(name="streamLastDeleteProcessedAt")
    def stream_last_delete_processed_at(self) -> Optional[str]:
        """
        ISO-8601 date when delete from source was last processed.
        """
        return pulumi.get(self, "stream_last_delete_processed_at")

    @property
    @pulumi.getter(name="streamLastInsertProcessedAt")
    def stream_last_insert_processed_at(self) -> Optional[str]:
        """
        ISO-8601 date when new insert from source was last processed.
        """
        return pulumi.get(self, "stream_last_insert_processed_at")

    @property
    @pulumi.getter(name="streamLastUpdateProcessedAt")
    def stream_last_update_processed_at(self) -> Optional[str]:
        """
        ISO-8601 date when update from source was last processed.
        """
        return pulumi.get(self, "stream_last_update_processed_at")

    @property
    @pulumi.getter(name="streamRecordsDeleted")
    def stream_records_deleted(self) -> Optional[int]:
        """
        Number of new records deleted using stream.
        """
        return pulumi.get(self, "stream_records_deleted")

    @property
    @pulumi.getter(name="streamRecordsInserted")
    def stream_records_inserted(self) -> Optional[int]:
        """
        Number of new records inserted using stream.
        """
        return pulumi.get(self, "stream_records_inserted")

    @property
    @pulumi.getter(name="streamRecordsUpdated")
    def stream_records_updated(self) -> Optional[int]:
        """
        Number of new records updated using stream.
        """
        return pulumi.get(self, "stream_records_updated")


@pulumi.output_type
class RocksetQueryLambdaSql(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultParameters":
            suggest = "default_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetQueryLambdaSql. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetQueryLambdaSql.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetQueryLambdaSql.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 default_parameters: Optional[Sequence['outputs.RocksetQueryLambdaSqlDefaultParameter']] = None):
        pulumi.set(__self__, "query", query)
        if default_parameters is not None:
            pulumi.set(__self__, "default_parameters", default_parameters)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="defaultParameters")
    def default_parameters(self) -> Optional[Sequence['outputs.RocksetQueryLambdaSqlDefaultParameter']]:
        return pulumi.get(self, "default_parameters")


@pulumi.output_type
class RocksetQueryLambdaSqlDefaultParameter(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Unique identifier for the query lambda. Can contain alphanumeric or dash characters.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Unique identifier for the query lambda. Can contain alphanumeric or dash characters.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class RocksetRolePrivilege(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetRolePrivilege. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetRolePrivilege.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetRolePrivilege.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 cluster: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str action: The action allowed by this privilege.
        :param str cluster: Rockset cluster ID for which this action is allowed. Only valid for Workspace actions. Use '*ALL*' for actions which apply to all clusters.
        :param str resource_name: The resource on which this action is allowed. Defaults to 'All' if not specified.
        """
        pulumi.set(__self__, "action", action)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action allowed by this privilege.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        Rockset cluster ID for which this action is allowed. Only valid for Workspace actions. Use '*ALL*' for actions which apply to all clusters.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        The resource on which this action is allowed. Defaults to 'All' if not specified.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class RocksetS3CollectionSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationName":
            suggest = "integration_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetS3CollectionSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetS3CollectionSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetS3CollectionSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 format: str,
                 integration_name: str,
                 csv: Optional['outputs.RocksetS3CollectionSourceCsv'] = None,
                 pattern: Optional[str] = None,
                 prefix: Optional[str] = None,
                 xml: Optional['outputs.RocksetS3CollectionSourceXml'] = None):
        """
        :param str bucket: S3 bucket containing the target data.
        :param str format: Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        :param str integration_name: The name of the Rockset S3 integration. If no S3 integration is provided only data in public S3 buckets are accessible.
        :param str pattern: Regex path pattern to S3 keys.
        :param str prefix: Simple path prefix to S3 keys.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "format", format)
        pulumi.set(__self__, "integration_name", integration_name)
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if xml is not None:
            pulumi.set(__self__, "xml", xml)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        S3 bucket containing the target data.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def format(self) -> str:
        """
        Format of the data. One of: json, csv, xml. xml and csv blocks can only be set for their respective formats.
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="integrationName")
    def integration_name(self) -> str:
        """
        The name of the Rockset S3 integration. If no S3 integration is provided only data in public S3 buckets are accessible.
        """
        return pulumi.get(self, "integration_name")

    @property
    @pulumi.getter
    def csv(self) -> Optional['outputs.RocksetS3CollectionSourceCsv']:
        return pulumi.get(self, "csv")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Regex path pattern to S3 keys.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        Simple path prefix to S3 keys.
        """
        return pulumi.get(self, "prefix")

    @property
    @pulumi.getter
    def xml(self) -> Optional['outputs.RocksetS3CollectionSourceXml']:
        return pulumi.get(self, "xml")


@pulumi.output_type
class RocksetS3CollectionSourceCsv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "columnNames":
            suggest = "column_names"
        elif key == "columnTypes":
            suggest = "column_types"
        elif key == "escapeChar":
            suggest = "escape_char"
        elif key == "firstLineAsColumnNames":
            suggest = "first_line_as_column_names"
        elif key == "quoteChar":
            suggest = "quote_char"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetS3CollectionSourceCsv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetS3CollectionSourceCsv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetS3CollectionSourceCsv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column_names: Optional[Sequence[str]] = None,
                 column_types: Optional[Sequence[str]] = None,
                 encoding: Optional[str] = None,
                 escape_char: Optional[str] = None,
                 first_line_as_column_names: Optional[bool] = None,
                 quote_char: Optional[str] = None,
                 separator: Optional[str] = None):
        if column_names is not None:
            pulumi.set(__self__, "column_names", column_names)
        if column_types is not None:
            pulumi.set(__self__, "column_types", column_types)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if escape_char is not None:
            pulumi.set(__self__, "escape_char", escape_char)
        if first_line_as_column_names is not None:
            pulumi.set(__self__, "first_line_as_column_names", first_line_as_column_names)
        if quote_char is not None:
            pulumi.set(__self__, "quote_char", quote_char)
        if separator is not None:
            pulumi.set(__self__, "separator", separator)

    @property
    @pulumi.getter(name="columnNames")
    def column_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_names")

    @property
    @pulumi.getter(name="columnTypes")
    def column_types(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "column_types")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="escapeChar")
    def escape_char(self) -> Optional[str]:
        return pulumi.get(self, "escape_char")

    @property
    @pulumi.getter(name="firstLineAsColumnNames")
    def first_line_as_column_names(self) -> Optional[bool]:
        return pulumi.get(self, "first_line_as_column_names")

    @property
    @pulumi.getter(name="quoteChar")
    def quote_char(self) -> Optional[str]:
        return pulumi.get(self, "quote_char")

    @property
    @pulumi.getter
    def separator(self) -> Optional[str]:
        return pulumi.get(self, "separator")


@pulumi.output_type
class RocksetS3CollectionSourceXml(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributePrefix":
            suggest = "attribute_prefix"
        elif key == "docTag":
            suggest = "doc_tag"
        elif key == "rootTag":
            suggest = "root_tag"
        elif key == "valueTag":
            suggest = "value_tag"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RocksetS3CollectionSourceXml. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RocksetS3CollectionSourceXml.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RocksetS3CollectionSourceXml.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_prefix: Optional[str] = None,
                 doc_tag: Optional[str] = None,
                 encoding: Optional[str] = None,
                 root_tag: Optional[str] = None,
                 value_tag: Optional[str] = None):
        if attribute_prefix is not None:
            pulumi.set(__self__, "attribute_prefix", attribute_prefix)
        if doc_tag is not None:
            pulumi.set(__self__, "doc_tag", doc_tag)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if root_tag is not None:
            pulumi.set(__self__, "root_tag", root_tag)
        if value_tag is not None:
            pulumi.set(__self__, "value_tag", value_tag)

    @property
    @pulumi.getter(name="attributePrefix")
    def attribute_prefix(self) -> Optional[str]:
        return pulumi.get(self, "attribute_prefix")

    @property
    @pulumi.getter(name="docTag")
    def doc_tag(self) -> Optional[str]:
        return pulumi.get(self, "doc_tag")

    @property
    @pulumi.getter
    def encoding(self) -> Optional[str]:
        return pulumi.get(self, "encoding")

    @property
    @pulumi.getter(name="rootTag")
    def root_tag(self) -> Optional[str]:
        return pulumi.get(self, "root_tag")

    @property
    @pulumi.getter(name="valueTag")
    def value_tag(self) -> Optional[str]:
        return pulumi.get(self, "value_tag")


@pulumi.output_type
class GetAccountClusterResult(dict):
    def __init__(__self__, *,
                 api_server: str,
                 aws_region: str,
                 type: str):
        pulumi.set(__self__, "api_server", api_server)
        pulumi.set(__self__, "aws_region", aws_region)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> str:
        return pulumi.get(self, "api_server")

    @property
    @pulumi.getter(name="awsRegion")
    def aws_region(self) -> str:
        return pulumi.get(self, "aws_region")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


