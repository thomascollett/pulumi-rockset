// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rockset

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type RocksetKafkaIntegration struct {
	pulumi.CustomResourceState

	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrOutput `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString pulumi.StringOutput `pulumi:"connectionString"`
	// Text describing the integration.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrOutput `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayOutput `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapOutput `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapOutput `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrOutput `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrOutput `pulumi:"waitForIntegration"`
}

// NewRocksetKafkaIntegration registers a new resource with the given unique name, arguments, and options.
func NewRocksetKafkaIntegration(ctx *pulumi.Context,
	name string, args *RocksetKafkaIntegrationArgs, opts ...pulumi.ResourceOption) (*RocksetKafkaIntegration, error) {
	if args == nil {
		args = &RocksetKafkaIntegrationArgs{}
	}

	opts = pkgResourceDefaultOpts(opts)
	var resource RocksetKafkaIntegration
	err := ctx.RegisterResource("rockset:index/rocksetKafkaIntegration:RocksetKafkaIntegration", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRocksetKafkaIntegration gets an existing RocksetKafkaIntegration resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRocksetKafkaIntegration(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RocksetKafkaIntegrationState, opts ...pulumi.ResourceOption) (*RocksetKafkaIntegration, error) {
	var resource RocksetKafkaIntegration
	err := ctx.ReadResource("rockset:index/rocksetKafkaIntegration:RocksetKafkaIntegration", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RocksetKafkaIntegration resources.
type rocksetKafkaIntegrationState struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString *string `pulumi:"connectionString"`
	// Text describing the integration.
	Description *string `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat *string `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames []string `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig map[string]string `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig map[string]string `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 *bool `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration *bool `pulumi:"waitForIntegration"`
}

type RocksetKafkaIntegrationState struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrInput
	// Kafka connection string.
	ConnectionString pulumi.StringPtrInput
	// Text describing the integration.
	Description pulumi.StringPtrInput
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrInput
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayInput
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapInput
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapInput
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrInput
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrInput
}

func (RocksetKafkaIntegrationState) ElementType() reflect.Type {
	return reflect.TypeOf((*rocksetKafkaIntegrationState)(nil)).Elem()
}

type rocksetKafkaIntegrationArgs struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers *string `pulumi:"bootstrapServers"`
	// Kafka connection string.
	ConnectionString *string `pulumi:"connectionString"`
	// Text describing the integration.
	Description *string `pulumi:"description"`
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat *string `pulumi:"kafkaDataFormat"`
	// Kafka topics to tail.
	KafkaTopicNames []string `pulumi:"kafkaTopicNames"`
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig map[string]string `pulumi:"schemaRegistryConfig"`
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig map[string]string `pulumi:"securityConfig"`
	// Use v3 for Confluent Cloud.
	UseV3 *bool `pulumi:"useV3"`
	// Wait until the integration is active.
	WaitForIntegration *bool `pulumi:"waitForIntegration"`
}

// The set of arguments for constructing a RocksetKafkaIntegration resource.
type RocksetKafkaIntegrationArgs struct {
	// The Kafka bootstrap server url(s). Required only for V3 integration.
	BootstrapServers pulumi.StringPtrInput
	// Kafka connection string.
	ConnectionString pulumi.StringPtrInput
	// Text describing the integration.
	Description pulumi.StringPtrInput
	// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
	KafkaDataFormat pulumi.StringPtrInput
	// Kafka topics to tail.
	KafkaTopicNames pulumi.StringArrayInput
	// Unique identifier for the integration. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Kafka configuration for schema registry. Required only for V3 integration.
	SchemaRegistryConfig pulumi.StringMapInput
	// Kafka security configurations. Required only for V3 integration.
	SecurityConfig pulumi.StringMapInput
	// Use v3 for Confluent Cloud.
	UseV3 pulumi.BoolPtrInput
	// Wait until the integration is active.
	WaitForIntegration pulumi.BoolPtrInput
}

func (RocksetKafkaIntegrationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rocksetKafkaIntegrationArgs)(nil)).Elem()
}

type RocksetKafkaIntegrationInput interface {
	pulumi.Input

	ToRocksetKafkaIntegrationOutput() RocksetKafkaIntegrationOutput
	ToRocksetKafkaIntegrationOutputWithContext(ctx context.Context) RocksetKafkaIntegrationOutput
}

func (*RocksetKafkaIntegration) ElementType() reflect.Type {
	return reflect.TypeOf((**RocksetKafkaIntegration)(nil)).Elem()
}

func (i *RocksetKafkaIntegration) ToRocksetKafkaIntegrationOutput() RocksetKafkaIntegrationOutput {
	return i.ToRocksetKafkaIntegrationOutputWithContext(context.Background())
}

func (i *RocksetKafkaIntegration) ToRocksetKafkaIntegrationOutputWithContext(ctx context.Context) RocksetKafkaIntegrationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaIntegrationOutput)
}

// RocksetKafkaIntegrationArrayInput is an input type that accepts RocksetKafkaIntegrationArray and RocksetKafkaIntegrationArrayOutput values.
// You can construct a concrete instance of `RocksetKafkaIntegrationArrayInput` via:
//
//	RocksetKafkaIntegrationArray{ RocksetKafkaIntegrationArgs{...} }
type RocksetKafkaIntegrationArrayInput interface {
	pulumi.Input

	ToRocksetKafkaIntegrationArrayOutput() RocksetKafkaIntegrationArrayOutput
	ToRocksetKafkaIntegrationArrayOutputWithContext(context.Context) RocksetKafkaIntegrationArrayOutput
}

type RocksetKafkaIntegrationArray []RocksetKafkaIntegrationInput

func (RocksetKafkaIntegrationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RocksetKafkaIntegration)(nil)).Elem()
}

func (i RocksetKafkaIntegrationArray) ToRocksetKafkaIntegrationArrayOutput() RocksetKafkaIntegrationArrayOutput {
	return i.ToRocksetKafkaIntegrationArrayOutputWithContext(context.Background())
}

func (i RocksetKafkaIntegrationArray) ToRocksetKafkaIntegrationArrayOutputWithContext(ctx context.Context) RocksetKafkaIntegrationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaIntegrationArrayOutput)
}

// RocksetKafkaIntegrationMapInput is an input type that accepts RocksetKafkaIntegrationMap and RocksetKafkaIntegrationMapOutput values.
// You can construct a concrete instance of `RocksetKafkaIntegrationMapInput` via:
//
//	RocksetKafkaIntegrationMap{ "key": RocksetKafkaIntegrationArgs{...} }
type RocksetKafkaIntegrationMapInput interface {
	pulumi.Input

	ToRocksetKafkaIntegrationMapOutput() RocksetKafkaIntegrationMapOutput
	ToRocksetKafkaIntegrationMapOutputWithContext(context.Context) RocksetKafkaIntegrationMapOutput
}

type RocksetKafkaIntegrationMap map[string]RocksetKafkaIntegrationInput

func (RocksetKafkaIntegrationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RocksetKafkaIntegration)(nil)).Elem()
}

func (i RocksetKafkaIntegrationMap) ToRocksetKafkaIntegrationMapOutput() RocksetKafkaIntegrationMapOutput {
	return i.ToRocksetKafkaIntegrationMapOutputWithContext(context.Background())
}

func (i RocksetKafkaIntegrationMap) ToRocksetKafkaIntegrationMapOutputWithContext(ctx context.Context) RocksetKafkaIntegrationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaIntegrationMapOutput)
}

type RocksetKafkaIntegrationOutput struct{ *pulumi.OutputState }

func (RocksetKafkaIntegrationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RocksetKafkaIntegration)(nil)).Elem()
}

func (o RocksetKafkaIntegrationOutput) ToRocksetKafkaIntegrationOutput() RocksetKafkaIntegrationOutput {
	return o
}

func (o RocksetKafkaIntegrationOutput) ToRocksetKafkaIntegrationOutputWithContext(ctx context.Context) RocksetKafkaIntegrationOutput {
	return o
}

// The Kafka bootstrap server url(s). Required only for V3 integration.
func (o RocksetKafkaIntegrationOutput) BootstrapServers() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringPtrOutput { return v.BootstrapServers }).(pulumi.StringPtrOutput)
}

// Kafka connection string.
func (o RocksetKafkaIntegrationOutput) ConnectionString() pulumi.StringOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringOutput { return v.ConnectionString }).(pulumi.StringOutput)
}

// Text describing the integration.
func (o RocksetKafkaIntegrationOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The format of the Kafka topics being tailed. Possible values: JSON, AVRO.
func (o RocksetKafkaIntegrationOutput) KafkaDataFormat() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringPtrOutput { return v.KafkaDataFormat }).(pulumi.StringPtrOutput)
}

// Kafka topics to tail.
func (o RocksetKafkaIntegrationOutput) KafkaTopicNames() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringArrayOutput { return v.KafkaTopicNames }).(pulumi.StringArrayOutput)
}

// Unique identifier for the integration. Can contain alphanumeric or dash characters.
func (o RocksetKafkaIntegrationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Kafka configuration for schema registry. Required only for V3 integration.
func (o RocksetKafkaIntegrationOutput) SchemaRegistryConfig() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringMapOutput { return v.SchemaRegistryConfig }).(pulumi.StringMapOutput)
}

// Kafka security configurations. Required only for V3 integration.
func (o RocksetKafkaIntegrationOutput) SecurityConfig() pulumi.StringMapOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.StringMapOutput { return v.SecurityConfig }).(pulumi.StringMapOutput)
}

// Use v3 for Confluent Cloud.
func (o RocksetKafkaIntegrationOutput) UseV3() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.BoolPtrOutput { return v.UseV3 }).(pulumi.BoolPtrOutput)
}

// Wait until the integration is active.
func (o RocksetKafkaIntegrationOutput) WaitForIntegration() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaIntegration) pulumi.BoolPtrOutput { return v.WaitForIntegration }).(pulumi.BoolPtrOutput)
}

type RocksetKafkaIntegrationArrayOutput struct{ *pulumi.OutputState }

func (RocksetKafkaIntegrationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RocksetKafkaIntegration)(nil)).Elem()
}

func (o RocksetKafkaIntegrationArrayOutput) ToRocksetKafkaIntegrationArrayOutput() RocksetKafkaIntegrationArrayOutput {
	return o
}

func (o RocksetKafkaIntegrationArrayOutput) ToRocksetKafkaIntegrationArrayOutputWithContext(ctx context.Context) RocksetKafkaIntegrationArrayOutput {
	return o
}

func (o RocksetKafkaIntegrationArrayOutput) Index(i pulumi.IntInput) RocksetKafkaIntegrationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RocksetKafkaIntegration {
		return vs[0].([]*RocksetKafkaIntegration)[vs[1].(int)]
	}).(RocksetKafkaIntegrationOutput)
}

type RocksetKafkaIntegrationMapOutput struct{ *pulumi.OutputState }

func (RocksetKafkaIntegrationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RocksetKafkaIntegration)(nil)).Elem()
}

func (o RocksetKafkaIntegrationMapOutput) ToRocksetKafkaIntegrationMapOutput() RocksetKafkaIntegrationMapOutput {
	return o
}

func (o RocksetKafkaIntegrationMapOutput) ToRocksetKafkaIntegrationMapOutputWithContext(ctx context.Context) RocksetKafkaIntegrationMapOutput {
	return o
}

func (o RocksetKafkaIntegrationMapOutput) MapIndex(k pulumi.StringInput) RocksetKafkaIntegrationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RocksetKafkaIntegration {
		return vs[0].(map[string]*RocksetKafkaIntegration)[vs[1].(string)]
	}).(RocksetKafkaIntegrationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaIntegrationInput)(nil)).Elem(), &RocksetKafkaIntegration{})
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaIntegrationArrayInput)(nil)).Elem(), RocksetKafkaIntegrationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaIntegrationMapInput)(nil)).Elem(), RocksetKafkaIntegrationMap{})
	pulumi.RegisterOutputType(RocksetKafkaIntegrationOutput{})
	pulumi.RegisterOutputType(RocksetKafkaIntegrationArrayOutput{})
	pulumi.RegisterOutputType(RocksetKafkaIntegrationMapOutput{})
}
