// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package rockset

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages a collection created from a Kafka source. The `useV3` field must match the integration which the collection is created from.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi/config"
//	"github.com/thomascollett/pulumi-rockset/sdk/go/rockset"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			cfg := config.New(ctx, "")
//			bootstrapServers := cfg.RequireObject("bootstrapServers")
//			apikey := cfg.RequireObject("apikey")
//			secret := cfg.RequireObject("secret")
//			confluentRocksetKafkaIntegration, err := rockset.NewRocksetKafkaIntegration(ctx, "confluentRocksetKafkaIntegration", &rockset.RocksetKafkaIntegrationArgs{
//				Description:      pulumi.String("Integration to ingest documents from Confluent Cloud"),
//				UseV3:            pulumi.Bool(true),
//				BootstrapServers: pulumi.Any(bootstrapServers),
//				SecurityConfig: pulumi.StringMap{
//					"api_key": pulumi.Any(apikey),
//					"secret":  pulumi.Any(secret),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			confluentRocksetWorkspace, err := rockset.NewRocksetWorkspace(ctx, "confluentRocksetWorkspace", &rockset.RocksetWorkspaceArgs{
//				Description: pulumi.String("Collections from Confluent Cloud topics."),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = rockset.NewRocksetKafkaCollection(ctx, "test", &rockset.RocksetKafkaCollectionArgs{
//				Workspace:     confluentRocksetWorkspace.Name,
//				Description:   pulumi.String("Collection from a Confluent Cloud topic."),
//				RetentionSecs: pulumi.Int(3600),
//				Sources: rockset.RocksetKafkaCollectionSourceArray{
//					&rockset.RocksetKafkaCollectionSourceArgs{
//						IntegrationName:   confluentRocksetKafkaIntegration.Name,
//						UseV3:             pulumi.Bool(true),
//						TopicName:         pulumi.String("test_json"),
//						OffsetResetPolicy: pulumi.String("EARLIEST"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type RocksetKafkaCollection struct {
	pulumi.CustomResourceState

	// Text describing the collection.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// **Deprecated** use ingestTransformation instead
	//
	// Deprecated: Use ingest_transformation instead
	FieldMappingQuery pulumi.StringPtrOutput `pulumi:"fieldMappingQuery"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrOutput `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringOutput `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrOutput `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources RocksetKafkaCollectionSourceArrayOutput `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrOutput `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrOutput `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace pulumi.StringOutput `pulumi:"workspace"`
}

// NewRocksetKafkaCollection registers a new resource with the given unique name, arguments, and options.
func NewRocksetKafkaCollection(ctx *pulumi.Context,
	name string, args *RocksetKafkaCollectionArgs, opts ...pulumi.ResourceOption) (*RocksetKafkaCollection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Workspace == nil {
		return nil, errors.New("invalid value for required argument 'Workspace'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource RocksetKafkaCollection
	err := ctx.RegisterResource("rockset:index/rocksetKafkaCollection:RocksetKafkaCollection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRocksetKafkaCollection gets an existing RocksetKafkaCollection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRocksetKafkaCollection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RocksetKafkaCollectionState, opts ...pulumi.ResourceOption) (*RocksetKafkaCollection, error) {
	var resource RocksetKafkaCollection
	err := ctx.ReadResource("rockset:index/rocksetKafkaCollection:RocksetKafkaCollection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering RocksetKafkaCollection resources.
type rocksetKafkaCollectionState struct {
	// Text describing the collection.
	Description *string `pulumi:"description"`
	// **Deprecated** use ingestTransformation instead
	//
	// Deprecated: Use ingest_transformation instead
	FieldMappingQuery *string `pulumi:"fieldMappingQuery"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation *string `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs *int `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources []RocksetKafkaCollectionSource `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection *bool `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments *int `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace *string `pulumi:"workspace"`
}

type RocksetKafkaCollectionState struct {
	// Text describing the collection.
	Description pulumi.StringPtrInput
	// **Deprecated** use ingestTransformation instead
	//
	// Deprecated: Use ingest_transformation instead
	FieldMappingQuery pulumi.StringPtrInput
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrInput
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrInput
	// Defines a source for this collection.
	Sources RocksetKafkaCollectionSourceArrayInput
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrInput
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrInput
	// The name of the workspace.
	Workspace pulumi.StringPtrInput
}

func (RocksetKafkaCollectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*rocksetKafkaCollectionState)(nil)).Elem()
}

type rocksetKafkaCollectionArgs struct {
	// Text describing the collection.
	Description *string `pulumi:"description"`
	// **Deprecated** use ingestTransformation instead
	//
	// Deprecated: Use ingest_transformation instead
	FieldMappingQuery *string `pulumi:"fieldMappingQuery"`
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation *string `pulumi:"ingestTransformation"`
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name *string `pulumi:"name"`
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs *int `pulumi:"retentionSecs"`
	// Defines a source for this collection.
	Sources []RocksetKafkaCollectionSource `pulumi:"sources"`
	// Wait until the collection is ready.
	WaitForCollection *bool `pulumi:"waitForCollection"`
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments *int `pulumi:"waitForDocuments"`
	// The name of the workspace.
	Workspace string `pulumi:"workspace"`
}

// The set of arguments for constructing a RocksetKafkaCollection resource.
type RocksetKafkaCollectionArgs struct {
	// Text describing the collection.
	Description pulumi.StringPtrInput
	// **Deprecated** use ingestTransformation instead
	//
	// Deprecated: Use ingest_transformation instead
	FieldMappingQuery pulumi.StringPtrInput
	// Ingest transformation SQL query. Turns the collection into insertOnly mode.
	IngestTransformation pulumi.StringPtrInput
	// Unique identifier for the collection. Can contain alphanumeric or dash characters.
	Name pulumi.StringPtrInput
	// Number of seconds after which data is purged. Based on event time.
	RetentionSecs pulumi.IntPtrInput
	// Defines a source for this collection.
	Sources RocksetKafkaCollectionSourceArrayInput
	// Wait until the collection is ready.
	WaitForCollection pulumi.BoolPtrInput
	// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
	WaitForDocuments pulumi.IntPtrInput
	// The name of the workspace.
	Workspace pulumi.StringInput
}

func (RocksetKafkaCollectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*rocksetKafkaCollectionArgs)(nil)).Elem()
}

type RocksetKafkaCollectionInput interface {
	pulumi.Input

	ToRocksetKafkaCollectionOutput() RocksetKafkaCollectionOutput
	ToRocksetKafkaCollectionOutputWithContext(ctx context.Context) RocksetKafkaCollectionOutput
}

func (*RocksetKafkaCollection) ElementType() reflect.Type {
	return reflect.TypeOf((**RocksetKafkaCollection)(nil)).Elem()
}

func (i *RocksetKafkaCollection) ToRocksetKafkaCollectionOutput() RocksetKafkaCollectionOutput {
	return i.ToRocksetKafkaCollectionOutputWithContext(context.Background())
}

func (i *RocksetKafkaCollection) ToRocksetKafkaCollectionOutputWithContext(ctx context.Context) RocksetKafkaCollectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaCollectionOutput)
}

// RocksetKafkaCollectionArrayInput is an input type that accepts RocksetKafkaCollectionArray and RocksetKafkaCollectionArrayOutput values.
// You can construct a concrete instance of `RocksetKafkaCollectionArrayInput` via:
//
//	RocksetKafkaCollectionArray{ RocksetKafkaCollectionArgs{...} }
type RocksetKafkaCollectionArrayInput interface {
	pulumi.Input

	ToRocksetKafkaCollectionArrayOutput() RocksetKafkaCollectionArrayOutput
	ToRocksetKafkaCollectionArrayOutputWithContext(context.Context) RocksetKafkaCollectionArrayOutput
}

type RocksetKafkaCollectionArray []RocksetKafkaCollectionInput

func (RocksetKafkaCollectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RocksetKafkaCollection)(nil)).Elem()
}

func (i RocksetKafkaCollectionArray) ToRocksetKafkaCollectionArrayOutput() RocksetKafkaCollectionArrayOutput {
	return i.ToRocksetKafkaCollectionArrayOutputWithContext(context.Background())
}

func (i RocksetKafkaCollectionArray) ToRocksetKafkaCollectionArrayOutputWithContext(ctx context.Context) RocksetKafkaCollectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaCollectionArrayOutput)
}

// RocksetKafkaCollectionMapInput is an input type that accepts RocksetKafkaCollectionMap and RocksetKafkaCollectionMapOutput values.
// You can construct a concrete instance of `RocksetKafkaCollectionMapInput` via:
//
//	RocksetKafkaCollectionMap{ "key": RocksetKafkaCollectionArgs{...} }
type RocksetKafkaCollectionMapInput interface {
	pulumi.Input

	ToRocksetKafkaCollectionMapOutput() RocksetKafkaCollectionMapOutput
	ToRocksetKafkaCollectionMapOutputWithContext(context.Context) RocksetKafkaCollectionMapOutput
}

type RocksetKafkaCollectionMap map[string]RocksetKafkaCollectionInput

func (RocksetKafkaCollectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RocksetKafkaCollection)(nil)).Elem()
}

func (i RocksetKafkaCollectionMap) ToRocksetKafkaCollectionMapOutput() RocksetKafkaCollectionMapOutput {
	return i.ToRocksetKafkaCollectionMapOutputWithContext(context.Background())
}

func (i RocksetKafkaCollectionMap) ToRocksetKafkaCollectionMapOutputWithContext(ctx context.Context) RocksetKafkaCollectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RocksetKafkaCollectionMapOutput)
}

type RocksetKafkaCollectionOutput struct{ *pulumi.OutputState }

func (RocksetKafkaCollectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**RocksetKafkaCollection)(nil)).Elem()
}

func (o RocksetKafkaCollectionOutput) ToRocksetKafkaCollectionOutput() RocksetKafkaCollectionOutput {
	return o
}

func (o RocksetKafkaCollectionOutput) ToRocksetKafkaCollectionOutputWithContext(ctx context.Context) RocksetKafkaCollectionOutput {
	return o
}

// Text describing the collection.
func (o RocksetKafkaCollectionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// **Deprecated** use ingestTransformation instead
//
// Deprecated: Use ingest_transformation instead
func (o RocksetKafkaCollectionOutput) FieldMappingQuery() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.StringPtrOutput { return v.FieldMappingQuery }).(pulumi.StringPtrOutput)
}

// Ingest transformation SQL query. Turns the collection into insertOnly mode.
func (o RocksetKafkaCollectionOutput) IngestTransformation() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.StringPtrOutput { return v.IngestTransformation }).(pulumi.StringPtrOutput)
}

// Unique identifier for the collection. Can contain alphanumeric or dash characters.
func (o RocksetKafkaCollectionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Number of seconds after which data is purged. Based on event time.
func (o RocksetKafkaCollectionOutput) RetentionSecs() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.IntPtrOutput { return v.RetentionSecs }).(pulumi.IntPtrOutput)
}

// Defines a source for this collection.
func (o RocksetKafkaCollectionOutput) Sources() RocksetKafkaCollectionSourceArrayOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) RocksetKafkaCollectionSourceArrayOutput { return v.Sources }).(RocksetKafkaCollectionSourceArrayOutput)
}

// Wait until the collection is ready.
func (o RocksetKafkaCollectionOutput) WaitForCollection() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.BoolPtrOutput { return v.WaitForCollection }).(pulumi.BoolPtrOutput)
}

// Wait until the collection has documents. The default is to wait for 0 documents, which means it doesn't wait.
func (o RocksetKafkaCollectionOutput) WaitForDocuments() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.IntPtrOutput { return v.WaitForDocuments }).(pulumi.IntPtrOutput)
}

// The name of the workspace.
func (o RocksetKafkaCollectionOutput) Workspace() pulumi.StringOutput {
	return o.ApplyT(func(v *RocksetKafkaCollection) pulumi.StringOutput { return v.Workspace }).(pulumi.StringOutput)
}

type RocksetKafkaCollectionArrayOutput struct{ *pulumi.OutputState }

func (RocksetKafkaCollectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*RocksetKafkaCollection)(nil)).Elem()
}

func (o RocksetKafkaCollectionArrayOutput) ToRocksetKafkaCollectionArrayOutput() RocksetKafkaCollectionArrayOutput {
	return o
}

func (o RocksetKafkaCollectionArrayOutput) ToRocksetKafkaCollectionArrayOutputWithContext(ctx context.Context) RocksetKafkaCollectionArrayOutput {
	return o
}

func (o RocksetKafkaCollectionArrayOutput) Index(i pulumi.IntInput) RocksetKafkaCollectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *RocksetKafkaCollection {
		return vs[0].([]*RocksetKafkaCollection)[vs[1].(int)]
	}).(RocksetKafkaCollectionOutput)
}

type RocksetKafkaCollectionMapOutput struct{ *pulumi.OutputState }

func (RocksetKafkaCollectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*RocksetKafkaCollection)(nil)).Elem()
}

func (o RocksetKafkaCollectionMapOutput) ToRocksetKafkaCollectionMapOutput() RocksetKafkaCollectionMapOutput {
	return o
}

func (o RocksetKafkaCollectionMapOutput) ToRocksetKafkaCollectionMapOutputWithContext(ctx context.Context) RocksetKafkaCollectionMapOutput {
	return o
}

func (o RocksetKafkaCollectionMapOutput) MapIndex(k pulumi.StringInput) RocksetKafkaCollectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *RocksetKafkaCollection {
		return vs[0].(map[string]*RocksetKafkaCollection)[vs[1].(string)]
	}).(RocksetKafkaCollectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaCollectionInput)(nil)).Elem(), &RocksetKafkaCollection{})
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaCollectionArrayInput)(nil)).Elem(), RocksetKafkaCollectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RocksetKafkaCollectionMapInput)(nil)).Elem(), RocksetKafkaCollectionMap{})
	pulumi.RegisterOutputType(RocksetKafkaCollectionOutput{})
	pulumi.RegisterOutputType(RocksetKafkaCollectionArrayOutput{})
	pulumi.RegisterOutputType(RocksetKafkaCollectionMapOutput{})
}
